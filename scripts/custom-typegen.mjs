import fs from 'fs';

// Helper to read the snapshot from the migration file
const migrationFile = fs.readdirSync('pb_migrations').find(f => f.includes('collections_snapshot.js'));
if (!migrationFile) {
  console.error("No snapshot migration found.");
  process.exit(1);
}

const content = fs.readFileSync(`pb_migrations/${migrationFile}`, 'utf8');
const snapshotMatch = content.match(/const snapshot = (\[[\s\S]*?\]);/);
if (!snapshotMatch) {
  console.error("Could not find snapshot in migration file.");
  process.exit(1);
}

const snapshot = JSON.parse(snapshotMatch[1]);

function formatEnumName(name) {
  return name.split('_').map(p => p.charAt(0).toUpperCase() + p.slice(1)).join('');
}

function generateTypes(collections) {
  let out = `/**
* This file was @generated by a custom typegen script.
* It extracts the schema from the latest collections snapshot migration.
*/

export enum Collections {
${collections.map(c => `\t${formatEnumName(c.name)} = "${c.name}",`).join('\n')}
}

// Alias types for improved usability
export type IsoDateString = string
export type RecordIdString = string
export type HTMLString = string

// System fields
export type BaseSystemFields<T = never> = {
\tid: RecordIdString
\tcreated: IsoDateString
\tupdated: IsoDateString
\tcollectionId: string
\tcollectionName: Collections
\texpand?: T
}

export type AuthSystemFields<T = never> = {
\temail: string
\temailVisibility: boolean
\tusername: string
\tverified: boolean
} & BaseSystemFields<T>

`;

  for (const collection of collections) {
    const typeName = formatEnumName(collection.name);
    const responseName = `${typeName}Response`;
    const recordName = `${typeName}Record`;

    out += `// Record types for ${collection.name}\n`;
    out += `export type ${recordName} = {\n`;
    
    for (const field of collection.fields) {
      if (field.system || field.name === 'id' || field.name === 'created' || field.name === 'updated') continue;
      if (collection.type === 'auth' && (field.name === 'email' || field.name === 'username' || field.name === 'verified')) continue;
      
      let type = 'any';
      switch (field.type) {
        case 'text':
        case 'email':
        case 'url':
        case 'date':
        case 'autodate':
          type = 'string';
          break;
        case 'number':
          type = 'number';
          break;
        case 'bool':
          type = 'boolean';
          break;
        case 'json':
          type = 'any';
          break;
        case 'file':
          type = field.maxSelect === 1 ? 'string' : 'string[]';
          break;
        case 'relation':
          type = field.maxSelect === 1 ? 'RecordIdString' : 'RecordIdString[]';
          break;
        case 'select':
          type = field.values.map(v => `"${v}"`).join(' | ');
          break;
      }
      
      const optional = field.required ? '' : '?';
      out += `\t${field.name}${optional}: ${type}\n`;
    }
    out += `}\n\n`;

    const systemFields = collection.type === 'auth' ? 'AuthSystemFields' : 'BaseSystemFields';
    out += `export type ${responseName}<Texpand = unknown> = Required<${recordName}> & ${systemFields}<Texpand>\n\n`;
  }

  out += `export type CollectionRecords = {\n`;
  for (const collection of collections) {
    out += `\t${collection.name}: ${formatEnumName(collection.name)}Record\n`;
  }
  out += `}\n\n`;

  out += `export type CollectionResponses = {\n`;
  for (const collection of collections) {
    out += `\t${collection.name}: ${formatEnumName(collection.name)}Response\n`;
  }
  out += `}\n`;

  return out;
}

const generated = generateTypes(snapshot);
fs.writeFileSync('src/types/pocketbase-types.ts', generated);
console.log("Types generated successfully in src/types/pocketbase-types.ts");
